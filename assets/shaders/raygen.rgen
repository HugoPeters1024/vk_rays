#version 460
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "common.glsl"

struct Vertex {
  vec3 pos;
  vec3 normal;
};

layout (buffer_reference, std430, buffer_reference_align = 16) buffer VertexData {
  Vertex vertices[];
};

layout (buffer_reference, std430, buffer_reference_align = 16) buffer IndexData {
  uint indices[];
};

layout (buffer_reference, std430, buffer_reference_align = 16) buffer UniformData {
  mat4 inverse_view;
  mat4 inverse_proj;
  uint entropy;
};



layout(set=0, binding=0, rgba32f) uniform image2D                  render_target;
layout(set=0, binding=1)          uniform accelerationStructureEXT topLevelAS;

layout(push_constant, std430) uniform Registers {
  UniformData un;
  VertexData  vd;
  IndexData   id;
} regs;

layout(location = 0) rayPayloadEXT Payload {
  vec3 normal;
  float t;
  vec3 color;
} payload;

uint getSeed() {
    return wang_hash(gl_LaunchIDEXT.x + gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y) * regs.un.entropy;
}

void main() {
  g_seed = getSeed();
  const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(randf(), randf());
  const vec2 inUV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;

  vec3 start_origin = (regs.un.inverse_view * vec4(0,0,0,1)).xyz;
  vec3 target = (regs.un.inverse_proj * vec4(d.x, d.y, 1, 1)).xyz;
  vec3 start_direction = (regs.un.inverse_view * vec4(normalize(target), 0)).xyz;


  float tmin = 0.01;
  float tmax = 100.0;

  vec3 accum = vec3(0.0);

  uint MAX_SAMPLES = 1;

  for(uint s=0; s<MAX_SAMPLES; s++) {
    vec3 origin = start_origin;
    vec3 direction = start_direction;
    vec3 mask = vec3(1.0);

    for (uint bounce=0; bounce<8; bounce++) {
      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
      if (payload.t == 0.0) {
        accum += mask * vec3(0.6);
        break;
      }

      origin = origin + direction * (payload.t - EPS);
      direction = SampleHemisphereCosine(payload.normal);
      vec3 color = payload.color;
      mask = mask * color;
    }
  }

  vec4 old_image = regs.un.entropy == 666 ? vec4(0) : imageLoad(render_target, ivec2(gl_LaunchIDEXT.xy));
  imageStore(render_target, ivec2(gl_LaunchIDEXT.xy), old_image + vec4(accum, float(MAX_SAMPLES)));
}
